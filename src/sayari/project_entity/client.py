# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.create_resolved_project_entity_request import CreateResolvedProjectEntityRequest
from ..core.request_options import RequestOptions
from .types.single_project_entity_response import SingleProjectEntityResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.pydantic_utilities import parse_obj_as
from ..shared_errors.errors.bad_request import BadRequest
from ..shared_errors.types.bad_request_response import BadRequestResponse
from ..shared_errors.errors.unauthorized import Unauthorized
from ..shared_errors.types.unauthorized_response import UnauthorizedResponse
from ..shared_errors.errors.not_found import NotFound
from ..shared_errors.types.not_found_response import NotFoundResponse
from ..shared_errors.errors.method_not_allowed import MethodNotAllowed
from ..shared_errors.types.method_not_allowed_response import MethodNotAllowedResponse
from ..shared_errors.errors.rate_limit_exceeded import RateLimitExceeded
from ..shared_errors.types.rate_limit_response import RateLimitResponse
from ..shared_errors.errors.internal_server_error import InternalServerError
from ..shared_errors.types.internal_server_error_response import InternalServerErrorResponse
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from .types.case_status import CaseStatus
from .types.match_result import MatchResult
from .types.match_strength_enum import MatchStrengthEnum
from ..generated_types.types.risk import Risk
from ..generated_types.types.risk_category import RiskCategory
from .types.project_entities_response import ProjectEntitiesResponse
from .types.resolution_attributes import ResolutionAttributes
from .types.project_entity_id_response import ProjectEntityIdResponse
from .types.save_project_entity_body import SaveProjectEntityBody
from ..generated_types.types.country import Country
from ..supply_chain.types.upstream_trade_traversal_response import UpstreamTradeTraversalResponse
from .types.project_entity_supply_chain_summary_response import ProjectEntitySupplyChainSummaryResponse
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProjectEntityClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_project_entity(
        self,
        project_id: str,
        *,
        request: CreateResolvedProjectEntityRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleProjectEntityResponse:
        """
        The resolution endpoints allow users to search for matching entities against a provided list of attributes. The endpoint is similar to the search endpoint, except it's tuned to only return the best match so the client doesn't need to do as much or any post-processing work to filter down results.

        Parameters
        ----------
        project_id : str

        request : CreateResolvedProjectEntityRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleProjectEntityResponse

        Examples
        --------
        from sayari import Sayari
        from sayari.project_entity import CreateResolvedProjectEntityRequest

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.create_project_entity(
            project_id="YVB88Y",
            request=CreateResolvedProjectEntityRequest(
                name=["VTB Bank"],
                country=["RUS"],
                address=["Moscow"],
                identifier=["253400V1H6ART1UQ0N98"],
                profile="corporate",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/create",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateResolvedProjectEntityRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SingleProjectEntityResponse,
                    parse_obj_as(
                        type_=SingleProjectEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_project_entities(
        self,
        project_id: str,
        *,
        entity_id: typing.Optional[typing.Sequence[str]] = None,
        uploads: typing.Optional[typing.Sequence[str]] = None,
        case_status: typing.Optional[typing.Sequence[CaseStatus]] = None,
        tags: typing.Optional[typing.Sequence[str]] = None,
        match_result: typing.Optional[typing.Sequence[MatchResult]] = None,
        match_strength_v_1: typing.Optional[typing.Sequence[MatchStrengthEnum]] = None,
        entity_types: typing.Optional[typing.Sequence[str]] = None,
        geo_facets: typing.Optional[bool] = None,
        exact_match: typing.Optional[bool] = None,
        hs_codes: typing.Optional[typing.Sequence[str]] = None,
        received_hs_codes: typing.Optional[typing.Sequence[str]] = None,
        shipped_hs_codes: typing.Optional[typing.Sequence[str]] = None,
        upstream_product: typing.Optional[typing.Sequence[str]] = None,
        limit: typing.Optional[int] = None,
        token: typing.Optional[str] = None,
        sort: typing.Optional[typing.Sequence[str]] = None,
        aggregations: typing.Optional[typing.Sequence[str]] = None,
        num_aggregation_buckets: typing.Optional[int] = None,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        risk_category: typing.Optional[typing.Sequence[RiskCategory]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntitiesResponse:
        """
        Retrieves a list of entities for a specific project with pagination support.

        Parameters
        ----------
        project_id : str

        entity_id : typing.Optional[typing.Sequence[str]]
            Filter by entity IDs

        uploads : typing.Optional[typing.Sequence[str]]
            Filter by upload IDs

        case_status : typing.Optional[typing.Sequence[CaseStatus]]
            Filter by case status

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tag IDs

        match_result : typing.Optional[typing.Sequence[MatchResult]]
            Filter by match result

        match_strength_v_1 : typing.Optional[typing.Sequence[MatchStrengthEnum]]
            Filter by match strength

        entity_types : typing.Optional[typing.Sequence[str]]
            Filter by entity types

        geo_facets : typing.Optional[bool]
            Include geo facets

        exact_match : typing.Optional[bool]
            Use exact matching

        hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by HS codes

        received_hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by received HS codes

        shipped_hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by shipped HS codes

        upstream_product : typing.Optional[typing.Sequence[str]]
            Filter by upstream product

        limit : typing.Optional[int]
            Maximum number of results to return

        token : typing.Optional[str]
            Pagination token

        sort : typing.Optional[typing.Sequence[str]]
            Sort fields

        aggregations : typing.Optional[typing.Sequence[str]]
            Fields to aggregate

        num_aggregation_buckets : typing.Optional[int]
            Number of aggregation buckets

        risk : typing.Optional[typing.Sequence[Risk]]
            List of risk factors to filter by

        risk_category : typing.Optional[typing.Sequence[RiskCategory]]
            List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntitiesResponse

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.get_project_entities(
            project_id="YVB88Y",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities",
            method="GET",
            params={
                "entity_id": entity_id,
                "uploads": uploads,
                "case_status": case_status,
                "tags": tags,
                "match_result": match_result,
                "match_strength_v1": match_strength_v_1,
                "entity_types": entity_types,
                "geo_facets": geo_facets,
                "exact_match": exact_match,
                "hs_codes": hs_codes,
                "received_hs_codes": received_hs_codes,
                "shipped_hs_codes": shipped_hs_codes,
                "upstream_product": upstream_product,
                "limit": limit,
                "token": token,
                "sort": sort,
                "aggregations": aggregations,
                "num_aggregation_buckets": num_aggregation_buckets,
                "risk": risk,
                "risk_category": risk_category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntitiesResponse,
                    parse_obj_as(
                        type_=ProjectEntitiesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_project_entity(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        entity_id: typing.Optional[typing.Sequence[str]] = None,
        uploads: typing.Optional[typing.Sequence[str]] = None,
        case_status: typing.Optional[typing.Sequence[CaseStatus]] = None,
        tags: typing.Optional[typing.Sequence[str]] = None,
        match_result: typing.Optional[typing.Sequence[MatchResult]] = None,
        match_strength_v_1: typing.Optional[typing.Sequence[MatchStrengthEnum]] = None,
        entity_types: typing.Optional[typing.Sequence[str]] = None,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        risk_category: typing.Optional[typing.Sequence[RiskCategory]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleProjectEntityResponse:
        """
        Retrieves a specific entity in a project.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        entity_id : typing.Optional[typing.Sequence[str]]
            Filter by entity IDs

        uploads : typing.Optional[typing.Sequence[str]]
            Filter by upload IDs

        case_status : typing.Optional[typing.Sequence[CaseStatus]]
            Filter by case status

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tag IDs

        match_result : typing.Optional[typing.Sequence[MatchResult]]
            Filter by match result

        match_strength_v_1 : typing.Optional[typing.Sequence[MatchStrengthEnum]]
            Filter by match strength

        entity_types : typing.Optional[typing.Sequence[str]]
            Filter by entity types

        risk : typing.Optional[typing.Sequence[Risk]]
            List of risk factors to filter by

        risk_category : typing.Optional[typing.Sequence[RiskCategory]]
            List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleProjectEntityResponse

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.get_project_entity(
            project_id="project_id",
            project_entity_id="project_entity_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}",
            method="GET",
            params={
                "entity_id": entity_id,
                "uploads": uploads,
                "case_status": case_status,
                "tags": tags,
                "match_result": match_result,
                "match_strength_v1": match_strength_v_1,
                "entity_types": entity_types,
                "risk": risk,
                "risk_category": risk_category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SingleProjectEntityResponse,
                    parse_obj_as(
                        type_=SingleProjectEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_project_entity(
        self, project_id: str, project_entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Deletes a project entity.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.delete_project_entity(
            project_id="project_id",
            project_entity_id="project_entity_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_project_entity_match(
        self,
        project_id: str,
        project_entity_id: str,
        match_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Deletes a specific project entity match.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        match_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.delete_project_entity_match(
            project_id="project_id",
            project_entity_id="project_entity_id",
            match_id="match_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/matches/{jsonable_encoder(match_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def project_entity_exists(
        self, project_id: str, *, request: ResolutionAttributes, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectEntityIdResponse:
        """
        Checks if a project entity with the given attributes already exists.

        Parameters
        ----------
        project_id : str

        request : ResolutionAttributes

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntityIdResponse

        Examples
        --------
        from sayari import Sayari
        from sayari.project_entity import ResolutionAttributes

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.project_entity_exists(
            project_id="YVB88Y",
            request=ResolutionAttributes(
                name=["Example Company"],
                country=["USA"],
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/exists",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ResolutionAttributes, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntityIdResponse,
                    parse_obj_as(
                        type_=ProjectEntityIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def save_project_entity(
        self,
        project_id: str,
        *,
        request: SaveProjectEntityBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntityIdResponse:
        """
        Stores a project entity given entity IDs and a list of attributes.

        Parameters
        ----------
        project_id : str

        request : SaveProjectEntityBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntityIdResponse

        Examples
        --------
        from sayari import Sayari
        from sayari.project_entity import ResolutionAttributes, SaveProjectEntityBody

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.save_project_entity(
            project_id="YVB88Y",
            request=SaveProjectEntityBody(
                entity_ids=["entity_id_1", "entity_id_2"],
                attributes=ResolutionAttributes(
                    name=["Example Company"],
                    country=["USA"],
                ),
                profile="corporate",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/save",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SaveProjectEntityBody, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntityIdResponse,
                    parse_obj_as(
                        type_=ProjectEntityIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def project_entity_supply_chain(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        not_risk: typing.Optional[typing.Sequence[Risk]] = None,
        countries: typing.Optional[typing.Sequence[Country]] = None,
        not_countries: typing.Optional[typing.Sequence[Country]] = None,
        shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        not_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_1_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_2_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_3_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_4_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_5_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        product: typing.Optional[typing.Sequence[str]] = None,
        not_product: typing.Optional[typing.Sequence[str]] = None,
        component: typing.Optional[typing.Sequence[str]] = None,
        not_component: typing.Optional[typing.Sequence[str]] = None,
        min_date: typing.Optional[str] = None,
        max_date: typing.Optional[str] = None,
        max_depth: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpstreamTradeTraversalResponse:
        """
        Execute a traversal of the upstream trade network (supply chain) for all matched entities of a project entity, returning a set of entities and edges between them.

        Parameters
        ----------
        project_id : str
            The project Identifier

        project_entity_id : str
            The project entity Identifier

        risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.

        not_risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.

        countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.

        not_countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.

        shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from any tier matches the provided values.

        not_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where none of the shipment countries from any tier matches the provided values.

        tier_1_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 1 matches the provided values.

        tier_2_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 2 matches the provided values.

        tier_3_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 3 matches the provided values.

        tier_4_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 4 matches the provided values.

        tier_5_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 5 matches the provided values.

        product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has 1+ of the specified HS codes.

        not_product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has none of the specified HS codes.

        component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.

        not_component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.

        min_date : typing.Optional[str]
            Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.

        max_date : typing.Optional[str]
            Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.

        max_depth : typing.Optional[int]
            The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.

        limit : typing.Optional[int]
            The maximum number of results to return. Default is no limit.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpstreamTradeTraversalResponse

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.project_entity_supply_chain(
            project_id="Gam5qG",
            project_entity_id="GOeOE8",
            min_date="2023-03-15",
            product=["3204"],
            risk=["forced_labor_xinjiang_origin_subtier"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/supply_chain/upstream",
            method="GET",
            params={
                "risk": risk,
                "-risk": not_risk,
                "countries": countries,
                "-countries": not_countries,
                "shipment_country": shipment_country,
                "-shipment_country": not_shipment_country,
                "tier1_shipment_country": tier_1_shipment_country,
                "tier2_shipment_country": tier_2_shipment_country,
                "tier3_shipment_country": tier_3_shipment_country,
                "tier4_shipment_country": tier_4_shipment_country,
                "tier5_shipment_country": tier_5_shipment_country,
                "product": product,
                "-product": not_product,
                "component": component,
                "-component": not_component,
                "min_date": min_date,
                "max_date": max_date,
                "max_depth": max_depth,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UpstreamTradeTraversalResponse,
                    parse_obj_as(
                        type_=UpstreamTradeTraversalResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def project_entity_supply_chain_summary(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        risk_factors: typing.Optional[typing.Sequence[Risk]] = None,
        not_risk: typing.Optional[typing.Sequence[Risk]] = None,
        countries: typing.Optional[typing.Sequence[Country]] = None,
        not_countries: typing.Optional[typing.Sequence[Country]] = None,
        product: typing.Optional[typing.Sequence[str]] = None,
        not_product: typing.Optional[typing.Sequence[str]] = None,
        component: typing.Optional[typing.Sequence[str]] = None,
        not_component: typing.Optional[typing.Sequence[str]] = None,
        min_date: typing.Optional[str] = None,
        max_date: typing.Optional[str] = None,
        max_depth: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntitySupplyChainSummaryResponse:
        """
        Execute a traversal of the upstream trade network (supply chain) for all matched entities of a project entity, returning a summary of countries, risks, and components.

        Parameters
        ----------
        project_id : str
            The project Identifier

        project_entity_id : str
            The project entity Identifier

        risk_factors : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.

        not_risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.

        countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.

        not_countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.

        product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has 1+ of the specified HS codes.

        not_product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has none of the specified HS codes.

        component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.

        not_component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.

        min_date : typing.Optional[str]
            Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.

        max_date : typing.Optional[str]
            Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.

        max_depth : typing.Optional[int]
            The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.

        limit : typing.Optional[int]
            The maximum number of results to return. Default is no limit.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntitySupplyChainSummaryResponse

        Examples
        --------
        from sayari import Sayari

        client = Sayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )
        client.project_entity.project_entity_supply_chain_summary(
            project_id="Gam5qG",
            project_entity_id="GOeOE8",
            min_date="2023-03-15",
            product=["8536", "8544", "4016"],
            risk_factors=[
                "forced_labor_xinjiang_name",
                "forced_labor_xinjiang_uflpa",
                "forced_labor_uflpa_origin_direct",
                "exports_russian_gold",
                "export_to_sanctioned",
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/supply_chain/upstream_summary",
            method="GET",
            params={
                "risk_factors": risk_factors,
                "-risk_factors": not_risk,
                "countries": countries,
                "-countries": not_countries,
                "product": product,
                "-product": not_product,
                "component": component,
                "-component": not_component,
                "min_date": min_date,
                "max_date": max_date,
                "max_depth": max_depth,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntitySupplyChainSummaryResponse,
                    parse_obj_as(
                        type_=ProjectEntitySupplyChainSummaryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProjectEntityClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_project_entity(
        self,
        project_id: str,
        *,
        request: CreateResolvedProjectEntityRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleProjectEntityResponse:
        """
        The resolution endpoints allow users to search for matching entities against a provided list of attributes. The endpoint is similar to the search endpoint, except it's tuned to only return the best match so the client doesn't need to do as much or any post-processing work to filter down results.

        Parameters
        ----------
        project_id : str

        request : CreateResolvedProjectEntityRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleProjectEntityResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari
        from sayari.project_entity import CreateResolvedProjectEntityRequest

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.create_project_entity(
                project_id="YVB88Y",
                request=CreateResolvedProjectEntityRequest(
                    name=["VTB Bank"],
                    country=["RUS"],
                    address=["Moscow"],
                    identifier=["253400V1H6ART1UQ0N98"],
                    profile="corporate",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/create",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=CreateResolvedProjectEntityRequest, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SingleProjectEntityResponse,
                    parse_obj_as(
                        type_=SingleProjectEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_project_entities(
        self,
        project_id: str,
        *,
        entity_id: typing.Optional[typing.Sequence[str]] = None,
        uploads: typing.Optional[typing.Sequence[str]] = None,
        case_status: typing.Optional[typing.Sequence[CaseStatus]] = None,
        tags: typing.Optional[typing.Sequence[str]] = None,
        match_result: typing.Optional[typing.Sequence[MatchResult]] = None,
        match_strength_v_1: typing.Optional[typing.Sequence[MatchStrengthEnum]] = None,
        entity_types: typing.Optional[typing.Sequence[str]] = None,
        geo_facets: typing.Optional[bool] = None,
        exact_match: typing.Optional[bool] = None,
        hs_codes: typing.Optional[typing.Sequence[str]] = None,
        received_hs_codes: typing.Optional[typing.Sequence[str]] = None,
        shipped_hs_codes: typing.Optional[typing.Sequence[str]] = None,
        upstream_product: typing.Optional[typing.Sequence[str]] = None,
        limit: typing.Optional[int] = None,
        token: typing.Optional[str] = None,
        sort: typing.Optional[typing.Sequence[str]] = None,
        aggregations: typing.Optional[typing.Sequence[str]] = None,
        num_aggregation_buckets: typing.Optional[int] = None,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        risk_category: typing.Optional[typing.Sequence[RiskCategory]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntitiesResponse:
        """
        Retrieves a list of entities for a specific project with pagination support.

        Parameters
        ----------
        project_id : str

        entity_id : typing.Optional[typing.Sequence[str]]
            Filter by entity IDs

        uploads : typing.Optional[typing.Sequence[str]]
            Filter by upload IDs

        case_status : typing.Optional[typing.Sequence[CaseStatus]]
            Filter by case status

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tag IDs

        match_result : typing.Optional[typing.Sequence[MatchResult]]
            Filter by match result

        match_strength_v_1 : typing.Optional[typing.Sequence[MatchStrengthEnum]]
            Filter by match strength

        entity_types : typing.Optional[typing.Sequence[str]]
            Filter by entity types

        geo_facets : typing.Optional[bool]
            Include geo facets

        exact_match : typing.Optional[bool]
            Use exact matching

        hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by HS codes

        received_hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by received HS codes

        shipped_hs_codes : typing.Optional[typing.Sequence[str]]
            Filter by shipped HS codes

        upstream_product : typing.Optional[typing.Sequence[str]]
            Filter by upstream product

        limit : typing.Optional[int]
            Maximum number of results to return

        token : typing.Optional[str]
            Pagination token

        sort : typing.Optional[typing.Sequence[str]]
            Sort fields

        aggregations : typing.Optional[typing.Sequence[str]]
            Fields to aggregate

        num_aggregation_buckets : typing.Optional[int]
            Number of aggregation buckets

        risk : typing.Optional[typing.Sequence[Risk]]
            List of risk factors to filter by

        risk_category : typing.Optional[typing.Sequence[RiskCategory]]
            List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntitiesResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.get_project_entities(
                project_id="YVB88Y",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities",
            method="GET",
            params={
                "entity_id": entity_id,
                "uploads": uploads,
                "case_status": case_status,
                "tags": tags,
                "match_result": match_result,
                "match_strength_v1": match_strength_v_1,
                "entity_types": entity_types,
                "geo_facets": geo_facets,
                "exact_match": exact_match,
                "hs_codes": hs_codes,
                "received_hs_codes": received_hs_codes,
                "shipped_hs_codes": shipped_hs_codes,
                "upstream_product": upstream_product,
                "limit": limit,
                "token": token,
                "sort": sort,
                "aggregations": aggregations,
                "num_aggregation_buckets": num_aggregation_buckets,
                "risk": risk,
                "risk_category": risk_category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntitiesResponse,
                    parse_obj_as(
                        type_=ProjectEntitiesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_project_entity(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        entity_id: typing.Optional[typing.Sequence[str]] = None,
        uploads: typing.Optional[typing.Sequence[str]] = None,
        case_status: typing.Optional[typing.Sequence[CaseStatus]] = None,
        tags: typing.Optional[typing.Sequence[str]] = None,
        match_result: typing.Optional[typing.Sequence[MatchResult]] = None,
        match_strength_v_1: typing.Optional[typing.Sequence[MatchStrengthEnum]] = None,
        entity_types: typing.Optional[typing.Sequence[str]] = None,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        risk_category: typing.Optional[typing.Sequence[RiskCategory]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleProjectEntityResponse:
        """
        Retrieves a specific entity in a project.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        entity_id : typing.Optional[typing.Sequence[str]]
            Filter by entity IDs

        uploads : typing.Optional[typing.Sequence[str]]
            Filter by upload IDs

        case_status : typing.Optional[typing.Sequence[CaseStatus]]
            Filter by case status

        tags : typing.Optional[typing.Sequence[str]]
            Filter by tag IDs

        match_result : typing.Optional[typing.Sequence[MatchResult]]
            Filter by match result

        match_strength_v_1 : typing.Optional[typing.Sequence[MatchStrengthEnum]]
            Filter by match strength

        entity_types : typing.Optional[typing.Sequence[str]]
            Filter by entity types

        risk : typing.Optional[typing.Sequence[Risk]]
            List of risk factors to filter by

        risk_category : typing.Optional[typing.Sequence[RiskCategory]]
            List of risk categories to filter by. An entity matches if it has any risk factor belonging to one of the specified categories

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleProjectEntityResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.get_project_entity(
                project_id="project_id",
                project_entity_id="project_entity_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}",
            method="GET",
            params={
                "entity_id": entity_id,
                "uploads": uploads,
                "case_status": case_status,
                "tags": tags,
                "match_result": match_result,
                "match_strength_v1": match_strength_v_1,
                "entity_types": entity_types,
                "risk": risk,
                "risk_category": risk_category,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SingleProjectEntityResponse,
                    parse_obj_as(
                        type_=SingleProjectEntityResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_project_entity(
        self, project_id: str, project_entity_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Deletes a project entity.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.delete_project_entity(
                project_id="project_id",
                project_entity_id="project_entity_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_project_entity_match(
        self,
        project_id: str,
        project_entity_id: str,
        match_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Deletes a specific project entity match.

        Parameters
        ----------
        project_id : str

        project_entity_id : str

        match_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.delete_project_entity_match(
                project_id="project_id",
                project_entity_id="project_entity_id",
                match_id="match_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/matches/{jsonable_encoder(match_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def project_entity_exists(
        self, project_id: str, *, request: ResolutionAttributes, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectEntityIdResponse:
        """
        Checks if a project entity with the given attributes already exists.

        Parameters
        ----------
        project_id : str

        request : ResolutionAttributes

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntityIdResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari
        from sayari.project_entity import ResolutionAttributes

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.project_entity_exists(
                project_id="YVB88Y",
                request=ResolutionAttributes(
                    name=["Example Company"],
                    country=["USA"],
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/exists",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=ResolutionAttributes, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntityIdResponse,
                    parse_obj_as(
                        type_=ProjectEntityIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def save_project_entity(
        self,
        project_id: str,
        *,
        request: SaveProjectEntityBody,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntityIdResponse:
        """
        Stores a project entity given entity IDs and a list of attributes.

        Parameters
        ----------
        project_id : str

        request : SaveProjectEntityBody

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntityIdResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari
        from sayari.project_entity import ResolutionAttributes, SaveProjectEntityBody

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.save_project_entity(
                project_id="YVB88Y",
                request=SaveProjectEntityBody(
                    entity_ids=["entity_id_1", "entity_id_2"],
                    attributes=ResolutionAttributes(
                        name=["Example Company"],
                        country=["USA"],
                    ),
                    profile="corporate",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/save",
            method="POST",
            json=convert_and_respect_annotation_metadata(
                object_=request, annotation=SaveProjectEntityBody, direction="write"
            ),
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntityIdResponse,
                    parse_obj_as(
                        type_=ProjectEntityIdResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def project_entity_supply_chain(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        risk: typing.Optional[typing.Sequence[Risk]] = None,
        not_risk: typing.Optional[typing.Sequence[Risk]] = None,
        countries: typing.Optional[typing.Sequence[Country]] = None,
        not_countries: typing.Optional[typing.Sequence[Country]] = None,
        shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        not_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_1_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_2_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_3_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_4_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        tier_5_shipment_country: typing.Optional[typing.Sequence[Country]] = None,
        product: typing.Optional[typing.Sequence[str]] = None,
        not_product: typing.Optional[typing.Sequence[str]] = None,
        component: typing.Optional[typing.Sequence[str]] = None,
        not_component: typing.Optional[typing.Sequence[str]] = None,
        min_date: typing.Optional[str] = None,
        max_date: typing.Optional[str] = None,
        max_depth: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpstreamTradeTraversalResponse:
        """
        Execute a traversal of the upstream trade network (supply chain) for all matched entities of a project entity, returning a set of entities and edges between them.

        Parameters
        ----------
        project_id : str
            The project Identifier

        project_entity_id : str
            The project entity Identifier

        risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.

        not_risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.

        countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.

        not_countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.

        shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from any tier matches the provided values.

        not_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where none of the shipment countries from any tier matches the provided values.

        tier_1_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 1 matches the provided values.

        tier_2_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 2 matches the provided values.

        tier_3_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 3 matches the provided values.

        tier_4_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 4 matches the provided values.

        tier_5_shipment_country : typing.Optional[typing.Sequence[Country]]
            Filters supply chain paths where 1+ shipment country from tier 5 matches the provided values.

        product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has 1+ of the specified HS codes.

        not_product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has none of the specified HS codes.

        component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.

        not_component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.

        min_date : typing.Optional[str]
            Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.

        max_date : typing.Optional[str]
            Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.

        max_depth : typing.Optional[int]
            The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.

        limit : typing.Optional[int]
            The maximum number of results to return. Default is no limit.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpstreamTradeTraversalResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.project_entity_supply_chain(
                project_id="Gam5qG",
                project_entity_id="GOeOE8",
                min_date="2023-03-15",
                product=["3204"],
                risk=["forced_labor_xinjiang_origin_subtier"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/supply_chain/upstream",
            method="GET",
            params={
                "risk": risk,
                "-risk": not_risk,
                "countries": countries,
                "-countries": not_countries,
                "shipment_country": shipment_country,
                "-shipment_country": not_shipment_country,
                "tier1_shipment_country": tier_1_shipment_country,
                "tier2_shipment_country": tier_2_shipment_country,
                "tier3_shipment_country": tier_3_shipment_country,
                "tier4_shipment_country": tier_4_shipment_country,
                "tier5_shipment_country": tier_5_shipment_country,
                "product": product,
                "-product": not_product,
                "component": component,
                "-component": not_component,
                "min_date": min_date,
                "max_date": max_date,
                "max_depth": max_depth,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    UpstreamTradeTraversalResponse,
                    parse_obj_as(
                        type_=UpstreamTradeTraversalResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def project_entity_supply_chain_summary(
        self,
        project_id: str,
        project_entity_id: str,
        *,
        risk_factors: typing.Optional[typing.Sequence[Risk]] = None,
        not_risk: typing.Optional[typing.Sequence[Risk]] = None,
        countries: typing.Optional[typing.Sequence[Country]] = None,
        not_countries: typing.Optional[typing.Sequence[Country]] = None,
        product: typing.Optional[typing.Sequence[str]] = None,
        not_product: typing.Optional[typing.Sequence[str]] = None,
        component: typing.Optional[typing.Sequence[str]] = None,
        not_component: typing.Optional[typing.Sequence[str]] = None,
        min_date: typing.Optional[str] = None,
        max_date: typing.Optional[str] = None,
        max_depth: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProjectEntitySupplyChainSummaryResponse:
        """
        Execute a traversal of the upstream trade network (supply chain) for all matched entities of a project entity, returning a summary of countries, risks, and components.

        Parameters
        ----------
        project_id : str
            The project Identifier

        project_entity_id : str
            The project entity Identifier

        risk_factors : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has 1+ of the specified risk factors.

        not_risk : typing.Optional[typing.Sequence[Risk]]
            Risk leaf node filter. Only return supply chains that end with a supplier that has none of the specified risk factors.

        countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in 1+ of the specified countries.

        not_countries : typing.Optional[typing.Sequence[Country]]
            Country leaf node filter. Only return supply chains that end with a supplier in none of the specified countries.

        product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has 1+ of the specified HS codes.

        not_product : typing.Optional[typing.Sequence[str]]
            Product root edge filter. Only return supply chains that start with an edge that has none of the specified HS codes.

        component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain at least one edge with 1+ of the specified HS codes.

        not_component : typing.Optional[typing.Sequence[str]]
            Component edge filter. Only return supply chains that contain no edges with any of the specified HS codes.

        min_date : typing.Optional[str]
            Minimum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are greater than or equal to this date.

        max_date : typing.Optional[str]
            Maximum date edge filter in <YYYY-MM-DD> format. Only return supply chains with edge dates that are less than or equal to this date.

        max_depth : typing.Optional[int]
            The maximum depth of the traversal, from 1 to 4 inclusive. Default is 4. Reduce if query is timing out.

        limit : typing.Optional[int]
            The maximum number of results to return. Default is no limit.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectEntitySupplyChainSummaryResponse

        Examples
        --------
        import asyncio

        from sayari import AsyncSayari

        client = AsyncSayari(
            client_id="YOUR_CLIENT_ID",
            client_secret="YOUR_CLIENT_SECRET",
        )


        async def main() -> None:
            await client.project_entity.project_entity_supply_chain_summary(
                project_id="Gam5qG",
                project_entity_id="GOeOE8",
                min_date="2023-03-15",
                product=["8536", "8544", "4016"],
                risk_factors=[
                    "forced_labor_xinjiang_name",
                    "forced_labor_xinjiang_uflpa",
                    "forced_labor_uflpa_origin_direct",
                    "exports_russian_gold",
                    "export_to_sanctioned",
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/projects/{jsonable_encoder(project_id)}/entities/{jsonable_encoder(project_entity_id)}/supply_chain/upstream_summary",
            method="GET",
            params={
                "risk_factors": risk_factors,
                "-risk_factors": not_risk,
                "countries": countries,
                "-countries": not_countries,
                "product": product,
                "-product": not_product,
                "component": component,
                "-component": not_component,
                "min_date": min_date,
                "max_date": max_date,
                "max_depth": max_depth,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ProjectEntitySupplyChainSummaryResponse,
                    parse_obj_as(
                        type_=ProjectEntitySupplyChainSummaryResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequest(
                    typing.cast(
                        BadRequestResponse,
                        parse_obj_as(
                            type_=BadRequestResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise Unauthorized(
                    typing.cast(
                        UnauthorizedResponse,
                        parse_obj_as(
                            type_=UnauthorizedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFound(
                    typing.cast(
                        NotFoundResponse,
                        parse_obj_as(
                            type_=NotFoundResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 405:
                raise MethodNotAllowed(
                    typing.cast(
                        MethodNotAllowedResponse,
                        parse_obj_as(
                            type_=MethodNotAllowedResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise RateLimitExceeded(
                    typing.cast(
                        RateLimitResponse,
                        parse_obj_as(
                            type_=RateLimitResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        InternalServerErrorResponse,
                        parse_obj_as(
                            type_=InternalServerErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
