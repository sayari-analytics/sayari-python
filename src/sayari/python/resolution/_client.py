# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.remove_none_from_dict import remove_none_from_dict
from ..generated_types.country import Country
from ..generated_types.entities import Entities
from ..shared_errors.bad_request import BadRequest
from ..shared_errors.bad_request_response import BadRequestResponse
from ..shared_errors.internal_server_error import InternalServerError
from ..shared_errors.internal_server_error_response import InternalServerErrorResponse
from ..shared_errors.method_not_allowed import MethodNotAllowed
from ..shared_errors.method_not_allowed_response import MethodNotAllowedResponse
from ..shared_errors.not_acceptable import NotAcceptable
from ..shared_errors.not_acceptable_response import NotAcceptableResponse
from ..shared_errors.rate_limit_exceeded import RateLimitExceeded
from ..shared_errors.rate_limit_response import RateLimitResponse
from ..shared_errors.unauthorized import Unauthorized
from ..shared_errors.unauthorized_response import UnauthorizedResponse
from .resolution_response import ResolutionResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class ResolutionClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def resolution(
        self,
        *,
        name: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        identifier: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        country: typing.Optional[typing.Union[Country, typing.List[Country]]] = None,
        address: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        date_of_birth: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        contact: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        type: typing.Optional[typing.Union[Entities, typing.List[Entities]]] = None,
    ) -> ResolutionResponse:
        """
        The resolution endpoints allow users to search for matching entities against a provided list of attributes. The endpoint is similar to the search endpoint, except it's tuned to only return the best match so the client doesn't need to do as much or any post-processing work to filter down results.

        Parameters:
            - name: typing.Optional[typing.Union[str, typing.List[str]]]. Entity name

            - identifier: typing.Optional[typing.Union[str, typing.List[str]]]. Entity identifier

            - country: typing.Optional[typing.Union[Country, typing.List[Country]]]. Entity country - must be ISO (3166) Trigram i.e., `USA`

            - address: typing.Optional[typing.Union[str, typing.List[str]]]. Entity address

            - date_of_birth: typing.Optional[typing.Union[str, typing.List[str]]]. Entity date of birth

            - contact: typing.Optional[typing.Union[str, typing.List[str]]]. Entity contact

            - type: typing.Optional[typing.Union[Entities, typing.List[Entities]]]. Entity type. If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
        ---
        from sayari-analytics.client import SayariAnalyticsApi

        client = SayariAnalyticsApi(client_name="YOUR_CLIENT_NAME", token="YOUR_TOKEN", )
        client.resolution.resolution(name="victoria beckham limited", )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/resolution"),
            params=remove_none_from_dict(
                {
                    "name": name,
                    "identifier": identifier,
                    "country": country,
                    "address": address,
                    "date_of_birth": date_of_birth,
                    "contact": contact,
                    "type": type,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ResolutionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequest(pydantic.parse_obj_as(BadRequestResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise Unauthorized(pydantic.parse_obj_as(UnauthorizedResponse, _response.json()))  # type: ignore
        if _response.status_code == 405:
            raise MethodNotAllowed(pydantic.parse_obj_as(MethodNotAllowedResponse, _response.json()))  # type: ignore
        if _response.status_code == 406:
            raise NotAcceptable(pydantic.parse_obj_as(NotAcceptableResponse, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise RateLimitExceeded(pydantic.parse_obj_as(RateLimitResponse, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(InternalServerErrorResponse, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncResolutionClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def resolution(
        self,
        *,
        name: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        identifier: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        country: typing.Optional[typing.Union[Country, typing.List[Country]]] = None,
        address: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        date_of_birth: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        contact: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        type: typing.Optional[typing.Union[Entities, typing.List[Entities]]] = None,
    ) -> ResolutionResponse:
        """
        The resolution endpoints allow users to search for matching entities against a provided list of attributes. The endpoint is similar to the search endpoint, except it's tuned to only return the best match so the client doesn't need to do as much or any post-processing work to filter down results.

        Parameters:
            - name: typing.Optional[typing.Union[str, typing.List[str]]]. Entity name

            - identifier: typing.Optional[typing.Union[str, typing.List[str]]]. Entity identifier

            - country: typing.Optional[typing.Union[Country, typing.List[Country]]]. Entity country - must be ISO (3166) Trigram i.e., `USA`

            - address: typing.Optional[typing.Union[str, typing.List[str]]]. Entity address

            - date_of_birth: typing.Optional[typing.Union[str, typing.List[str]]]. Entity date of birth

            - contact: typing.Optional[typing.Union[str, typing.List[str]]]. Entity contact

            - type: typing.Optional[typing.Union[Entities, typing.List[Entities]]]. Entity type. If multiple values are passed for any field, the endpoint will match entities with ANY of the values.
        ---
        from sayari-analytics.client import AsyncSayariAnalyticsApi

        client = AsyncSayariAnalyticsApi(client_name="YOUR_CLIENT_NAME", token="YOUR_TOKEN", )
        await client.resolution.resolution(name="victoria beckham limited", )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/resolution"),
            params=remove_none_from_dict(
                {
                    "name": name,
                    "identifier": identifier,
                    "country": country,
                    "address": address,
                    "date_of_birth": date_of_birth,
                    "contact": contact,
                    "type": type,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ResolutionResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequest(pydantic.parse_obj_as(BadRequestResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise Unauthorized(pydantic.parse_obj_as(UnauthorizedResponse, _response.json()))  # type: ignore
        if _response.status_code == 405:
            raise MethodNotAllowed(pydantic.parse_obj_as(MethodNotAllowedResponse, _response.json()))  # type: ignore
        if _response.status_code == 406:
            raise NotAcceptable(pydantic.parse_obj_as(NotAcceptableResponse, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise RateLimitExceeded(pydantic.parse_obj_as(RateLimitResponse, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(InternalServerErrorResponse, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
