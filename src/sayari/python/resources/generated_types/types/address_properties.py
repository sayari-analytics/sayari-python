# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ....core.datetime_utils import serialize_datetime
from .address_type import AddressType
from .language import Language

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class AddressProperties(pydantic.BaseModel):
    building: typing.Optional[str] = None
    category: typing.Optional[str] = pydantic.Field(
        default=None, description='For category queries like "restaurants", etc.'
    )
    city: typing.Optional[str] = pydantic.Field(
        default=None, description="Any human settlement, including cities, towns, villages, hamlets, localities, etc."
    )
    city_district: typing.Optional[str] = pydantic.Field(
        default=None,
        description='Boroughs or districts within a city that serve some official purpose (e.g., "Brooklyn", "Hackney", or "Bratislava IV")',
    )
    country: typing.Optional[str] = pydantic.Field(
        default=None, description="Sovereign nations and their dependent territories; anything with an ISO 3166 code"
    )
    country_region: typing.Optional[str] = pydantic.Field(
        default=None, description="Informal subdivision of a country without any political status"
    )
    date: typing.Optional[str] = pydantic.Field(default=None, description="as-of date")
    entrance: typing.Optional[str] = pydantic.Field(default=None, description="Numbered/lettered entrance")
    from_date: typing.Optional[str] = pydantic.Field(default=None, description="start date")
    house: typing.Optional[str] = pydantic.Field(
        default=None, description='Building/site name (e.g., "Brooklyn Academy of Music", "Empire State Building")'
    )
    house_number: typing.Optional[str] = pydantic.Field(
        default=None,
        description="Usually refers to the external (street-facing) building number. In some jurisdictions, this may be a compound number that also includes an apartment/block number.",
    )
    island: typing.Optional[str] = pydantic.Field(default=None, description='Named islands (e.g., "Maui")')
    language: typing.Optional[Language] = pydantic.Field(
        default=None, description="The language in which the address was provided in the record"
    )
    level: typing.Optional[str] = pydantic.Field(
        default=None, description='Expressions indicating a floor number (e.g., "3rd Floor", "Ground Floor")'
    )
    metro_station: typing.Optional[str] = None
    near: typing.Optional[str] = pydantic.Field(
        default=None,
        description='Phrases like "in", "near", etc. used after a category phrase, to help with parsing queries like "restaurants in Brooklyn"',
    )
    normalized: str
    po_box: typing.Optional[str] = pydantic.Field(
        default=None, description="Typically found in non-physical (mail-only) addresses"
    )
    postcode: typing.Optional[str] = pydantic.Field(default=None, description="Postal codes used for mail sorting")
    precision_code: typing.Optional[str] = pydantic.Field(
        default=None, description="A code describing the precision of the X and Y coordinates"
    )
    road: typing.Optional[str] = pydantic.Field(default=None, description="Street name(s)")
    staircase: typing.Optional[str] = pydantic.Field(default=None, description="Numbered/lettered staircase")
    state: typing.Optional[str] = pydantic.Field(
        default=None,
        description='A first-level administrative division, including provinces and departments. Scotland, Northern Ireland, Wales, and England in the UK are also mapped to "state" (convention commonly used in geocoding tools).',
    )
    state_district: typing.Optional[str] = pydantic.Field(
        default=None, description="A second-level administrative division or county"
    )
    suburb: typing.Optional[str] = pydantic.Field(
        default=None,
        description='Usually an unofficial neighborhood name, like "Harlem", "South Bronx", or "Crown Heights"',
    )
    to_date: typing.Optional[str] = pydantic.Field(default=None, description="end date")
    translated: typing.Optional[str] = pydantic.Field(
        default=None, description="The address value translated to English"
    )
    transliterated: typing.Optional[str] = pydantic.Field(
        default=None, description="The address value transliterated to English"
    )
    type: typing.Optional[AddressType] = pydantic.Field(
        default=None,
        description="Indicates what the address is referring to. For example, it could be a physical address, mailing address, or other address type.",
    )
    unit: typing.Optional[str] = pydantic.Field(
        default=None, description="An apartment, unit, office, lot, or other secondary unit designator"
    )
    value: typing.Optional[str] = None
    world_region: typing.Optional[str] = pydantic.Field(
        default=None,
        description="Currently only used for appending “West Indies” after the country name, a pattern frequently used in the English-speaking Caribbean (e.g., “Jamaica, West Indies”)",
    )
    x: typing.Optional[float] = pydantic.Field(default=None, description="The X coordinate (longitude) of the address")
    y: typing.Optional[float] = pydantic.Field(default=None, description="The Y coordinate (latitude) of the address")

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
