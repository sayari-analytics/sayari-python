# This file was auto-generated by Fern from our API Definition.

import time
import typing

import httpx

from .auth._client import AsyncAuthClient, AuthClient
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .entity._client import AsyncEntityClient, EntityClient
from .environment import SayariAnalyticsApiEnvironment
from .info._client import AsyncInfoClient, InfoClient
from .record._client import AsyncRecordClient, RecordClient
from .resolution._client import AsyncResolutionClient, ResolutionClient
from .search._client import AsyncSearchClient, SearchClient
from .source._client import AsyncSourceClient, SourceClient
from .trade._client import AsyncTradeClient, TradeClient
from .traversal._client import AsyncTraversalClient, TraversalClient

# Because this rate limiter doesn't block all requests, we need a relatively high limit to cope with racing threads.
retry_limit = 10


class Retry(httpx.HTTPTransport):
    def handle_request(self, request: httpx.Request) -> httpx.Response:
        retry = 0
        resp = None
        while retry < retry_limit:
            retry += 1
            try:
                if resp is not None:
                    resp.close()
                resp = super().handle_request(request)
            # Retry on request exception
            except Exception as e:
                print("httpx {} exception {} caught - retrying".format(request.url, e))
                time.sleep(1)
                continue
            # Retry on 429
            if resp.status_code == 429:
                retry_delay = resp.headers.get("Retry-After")
                print("httpx {} 429 response - retrying after {}s".format(request.url, retry_delay))
                # Sleep for the requested amount of time
                time.sleep(int(retry_delay))
                continue
            # Retry on 502
            if resp.status_code == 502:
                print("httpx {} 502 response - retrying after 30s".format(request.url))
                time.sleep(30)
                continue
            content_type = resp.headers.get("Content-Type")
            if content_type is not None:
                mime_type, _, _ = content_type.partition(";")
                if mime_type == "application/json":
                    try:
                        resp.read()
                        resp.json()
                    except Exception as e:
                        print("httpx {} response not valid json '{}' - retrying".format(request.url, e))
                        continue
            break
        return resp


class SayariAnalyticsApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: SayariAnalyticsApiEnvironment = SayariAnalyticsApiEnvironment.PRODUCTION,
        client_name: str,
        token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.Client] = None
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            client_name=client_name,
            token=token,
            httpx_client=httpx.Client(timeout=timeout, transport=Retry()) if httpx_client is None else httpx_client,
        )
        self.auth = AuthClient(client_wrapper=self._client_wrapper)
        self.entity = EntityClient(client_wrapper=self._client_wrapper)
        self.info = InfoClient(client_wrapper=self._client_wrapper)
        self.record = RecordClient(client_wrapper=self._client_wrapper)
        self.resolution = ResolutionClient(client_wrapper=self._client_wrapper)
        self.search = SearchClient(client_wrapper=self._client_wrapper)
        self.source = SourceClient(client_wrapper=self._client_wrapper)
        self.trade = TradeClient(client_wrapper=self._client_wrapper)
        self.traversal = TraversalClient(client_wrapper=self._client_wrapper)


class AsyncSayariAnalyticsApi:
    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: SayariAnalyticsApiEnvironment = SayariAnalyticsApiEnvironment.PRODUCTION,
        client_name: str,
        token: typing.Optional[typing.Union[str, typing.Callable[[], str]]] = None,
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.AsyncClient] = None
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            client_name=client_name,
            token=token,
            httpx_client=httpx.AsyncClient(timeout=timeout, transport=Retry())
            if httpx_client is None
            else httpx_client,
        )
        self.auth = AsyncAuthClient(client_wrapper=self._client_wrapper)
        self.entity = AsyncEntityClient(client_wrapper=self._client_wrapper)
        self.info = AsyncInfoClient(client_wrapper=self._client_wrapper)
        self.record = AsyncRecordClient(client_wrapper=self._client_wrapper)
        self.resolution = AsyncResolutionClient(client_wrapper=self._client_wrapper)
        self.search = AsyncSearchClient(client_wrapper=self._client_wrapper)
        self.source = AsyncSourceClient(client_wrapper=self._client_wrapper)
        self.trade = AsyncTradeClient(client_wrapper=self._client_wrapper)
        self.traversal = AsyncTraversalClient(client_wrapper=self._client_wrapper)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: SayariAnalyticsApiEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
